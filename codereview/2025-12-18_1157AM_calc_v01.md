# Project: calc

## Table of Contents

- [src/hundred_problems.rs](#file-src-hundred-problems-rs)
- [src/main.rs](#file-src-main-rs)

## File: src/hundred_problems.rs <a id="file-src-hundred-problems-rs"></a>

```rust
use printpdf::*;
use rand::Rng;
use std::collections::HashSet;
use std::env::args;
use std::error::Error;
use std::fs::File;
use std::io::BufWriter;

// å®šä¹‰é¢˜ç›®ç±»å‹
#[derive(Debug, Clone, Copy)]
pub enum Operation {
    Add,
    Subtract,
    Multiply,
    Divide,
}

impl Operation {
    pub fn to_symbol(&self) -> &str {
        match self {
            Operation::Add => "+",
            Operation::Subtract => "-",
            Operation::Multiply => "Ã—",
            Operation::Divide => "Ã·",
        }
    }

    pub fn random() -> Self {
        let mut rng = rand::thread_rng();
        match rng.gen_range(0..4) {
            0 => Operation::Add,
            1 => Operation::Subtract,
            2 => Operation::Multiply,
            _ => Operation::Divide,
        }
    }
}

// å®šä¹‰ä¸€é“é¢˜ç›®
#[derive(Debug)]
pub struct MathProblem {
    pub a: u8,
    pub b: u8,
    pub op: Operation,
}

impl MathProblem {
    pub fn new() -> Self {
        let mut rng = rand::thread_rng();
        let op = Operation::random();

        match op {
            Operation::Add => {
                // åŠ æ³•ï¼šå’Œä¸è¶…è¿‡100
                let a = rng.gen_range(10..90);
                let b = rng.gen_range(1..(100 - a + 1));
                MathProblem { a, b, op }
            }
            Operation::Subtract => {
                // å‡æ³•ï¼šç»“æœéè´Ÿï¼Œè¢«å‡æ•°ä¸è¶…è¿‡100
                let a = rng.gen_range(20..100);
                let b = rng.gen_range(1..a);
                MathProblem { a, b, op }
            }
            Operation::Multiply => {
                // ä¹˜æ³•ï¼šè¡¨å†…ä¹˜æ³•ï¼Œä¸è¶…è¿‡9Ã—9
                let a = rng.gen_range(2..10);
                let b = rng.gen_range(2..10);
                MathProblem { a, b, op }
            }
            Operation::Divide => {
                // é™¤æ³•ï¼šè¡¨å†…é™¤æ³•ï¼Œæ•´é™¤
                let a = rng.gen_range(4..=81);
                // æ‰¾åˆ°açš„å› æ•°ä½œä¸ºb
                let mut factors = Vec::new();
                for i in 2..=9 {
                    if a % i == 0 && a / i >= 2 && a / i <= 9 {
                        factors.push(i);
                    }
                }

                if factors.is_empty() {
                    // å¦‚æœæ²¡æœ‰åˆé€‚çš„å› æ•°ï¼Œé‡æ–°ç”Ÿæˆ
                    Self::new()
                } else {
                    let idx = rng.gen_range(0..factors.len());
                    let b = factors[idx];
                    MathProblem { a, b, op }
                }
            }
        }
    }

    pub fn to_string(&self) -> String {
        format!("{:>2} {} {:>2} =", self.a, self.op.to_symbol(), self.b)
    }
}

pub fn generate_problems(count: usize) -> Vec<MathProblem> {
    let mut problems = Vec::new();
    let mut seen = HashSet::new();

    while problems.len() < count {
        let problem = MathProblem::new();
        let problem_str = problem.to_string();

        // é¿å…é‡å¤é¢˜ç›®
        if !seen.contains(&problem_str) {
            seen.insert(problem_str.clone());
            problems.push(problem);
        }
    }

    problems
}

pub fn create_pdf(
    problems: &[MathProblem],
    filename: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºPDFæ–‡æ¡£ - A4å¤§å°
    let (doc, page1, layer1) = PdfDocument::new(
        "MathProblems",
        Mm(210.0), // A4å®½åº¦
        Mm(297.0), // A4é«˜åº¦
        "Layer 1",
    );

    let current_layer = doc.get_page(page1).get_layer(layer1);

    // è®¾ç½®å­—ä½“ - ä½¿ç”¨ç­‰å®½å­—ä½“ç¡®ä¿å¯¹é½
    let font = doc.add_builtin_font(BuiltinFont::Courier)?;

    // é¡µé¢å¸ƒå±€å‚æ•°
    let page_width = 210.0;
    let page_height = 297.0;
    let margin = 20.0; // è¾¹è·

    // è®¡ç®—å¯ç”¨çš„å®½åº¦å’Œé«˜åº¦
    let usable_width = page_width - 2.0 * margin;
    let usable_height = page_height - 2.0 * margin;

    // æ¯è¡Œ4é“é¢˜ï¼Œå…±25è¡Œï¼ˆ100é“é¢˜ï¼‰
    let cols = 4;
    let rows = 25;

    // è®¡ç®—æ¯åˆ—çš„å®½åº¦
    let col_width = usable_width / cols as f32;

    // è®¡ç®—è¡Œé«˜
    let row_height = usable_height / rows as f32;

    // å­—ä½“å¤§å°
    let font_size = 14.0;

    // ç”Ÿæˆå¹¶æ’åˆ—é¢˜ç›®
    for (index, problem) in problems.iter().enumerate() {
        let row = index / cols;
        let col = index % cols;

        // è®¡ç®—åæ ‡
        let x = margin + (col as f32 * col_width) + (col_width - 40.0) / 2.0;
        let y = page_height
            - margin
            - (row as f32 * row_height)
            - (row_height - font_size / 2.85) / 2.0;

        // æ·»åŠ é¢˜ç›®æ–‡æœ¬
        current_layer.use_text(&problem.to_string(), font_size, Mm(x), Mm(y), &font);
    }

    // ä¿å­˜PDF
    doc.save(&mut BufWriter::new(File::create(filename)?))?;

    Ok(())
}

// è¿è¡Œç¨‹åº
pub fn run() -> Result<(), Box<dyn Error>> {
    let count = args()
        .skip(1)
        .next()
        .unwrap_or("1".into())
        .trim()
        .parse::<u8>()?;
    for page in 0..count {
        // ç”Ÿæˆ100é“é¢˜ç›®
        let problems = generate_problems(100);
        // æ˜¾ç¤ºé¢˜ç›®é¢„è§ˆ
        // println!("\né¢˜ç›®é¢„è§ˆï¼ˆå‰20é“ï¼‰ï¼š");
        // println!("{}", "=".repeat(60));
        // for (i, chunk) in problems.chunks(4).enumerate() {
        //     if i >= 5 {
        //         break;
        //     } // åªæ˜¾ç¤ºå‰5è¡Œ
        //     for problem in chunk {
        //         print!("{}    ", problem.to_string());
        //     }
        //     println!();
        // }
        // println!("{}", "=".repeat(60));

        // åˆ›å»ºPDF
        // let filename = "å£ç®—é¢˜.pdf";
        let filename = format!("å£ç®—é¢˜ - {}.pdf", page + 1);
        create_pdf(&problems, &filename)?;

        println!("\nâœ… å·²ç”Ÿæˆ100é“å£ç®—é¢˜ï¼");
        println!("\nğŸ“„ æ–‡ä»¶å·²ä¿å­˜ä¸ºï¼š{}", filename);

        // ç»Ÿè®¡é¢˜ç›®ç±»å‹
        let mut counts = [0; 4]; // [åŠ , å‡, ä¹˜, é™¤]
        for problem in &problems {
            match problem.op {
                Operation::Add => counts[0] += 1,
                Operation::Subtract => counts[1] += 1,
                Operation::Multiply => counts[2] += 1,
                Operation::Divide => counts[3] += 1,
            }
        }
    }

    // println!("\nğŸ“Š é¢˜ç›®ç±»å‹åˆ†å¸ƒï¼š");
    // println!("  åŠ æ³•ï¼š{}é“", counts[0]);
    // println!("  å‡æ³•ï¼š{}é“", counts[1]);
    // println!("  ä¹˜æ³•ï¼š{}é“", counts[2]);
    // println!("  é™¤æ³•ï¼š{}é“", counts[3]);

    Ok(())
}

```

## File: src/main.rs <a id="file-src-main-rs"></a>

```rust
use crate::hundred_problems::run;

mod hundred_problems;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("æ­£åœ¨ç”Ÿæˆæ•°å­¦å£ç®—é¢˜");
    run()?;
    Ok(())
}

```

